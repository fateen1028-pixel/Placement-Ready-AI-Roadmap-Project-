skill: complexity
version: v2
description: >
  Foundational curriculum for Big O analysis and computational cost modeling.
  Focuses on growth rates, worst-case analysis, and space-time tradeoffs.

slots:
  # =========================================================
  # SLOT 1 — BASIC GROWTH RANKING
  # =========================================================
  - slot_id: CORE_SLOT_1_COMPLEXITY_GROWTH
    mental_install: "Big O describes how resource requirements grow as input size N increases."
    invariant: "Function growth rate > constant factors at scale."
    mastery_signals:
      - Ranks O(1), O(log N), O(N), O(N log N), O(N^2) correctly
    hard_failures:
      - Thinks O(2N) is different from O(N)
      - Confuses N with constant value

    templates:
      - id: complexity_s1_rank_growth
        type: mcq
        difficulty: easy
        prompt: "Which of the following time complexities grows the SLOWEST as N becomes very large?"
        options:
          - "O(N)"
          - "O(log N)"
          - "O(N^2)"
          - "O(1)"
        correct_answer: 3
        concepts: [growth_rates, big_o]
      
      - id: complexity_s1_remediation_scaling
        type: explanation
        variant: remediation
        difficulty: easy
        prompt: |
          Think of Big O as "How much more work do I do if I double the input?"
          If doubling the input (N to 2N) doubles the time, it's O(N).
          If doubling the input only adds one small step, it's O(log N).
        concepts: [mental_model, scaling]

  # =========================================================
  # SLOT 2 — LOGARITHMIC INTUITION
  # =========================================================
  - slot_id: CORE_SLOT_2_COMPLEXITY_LOGARITHMS
    mental_install: "Logarithms emerge from repeated division."
    invariant: "N steps -> Log N steps by halving."
    mastery_signals:
      - Associates halving with Log N
    hard_failures:
      - Thinks straight line search is Log N

    templates:
      - id: complexity_s1_log_origin
        type: explanation
        difficulty: medium
        prompt: |
          In algorithms like Binary Search, we say the complexity is O(log N). 
          Explain what physical action in an algorithm typically leads to a logarithmic growth rate.
        rubric: "Must mention repeatedly dividing the search space or input size by a constant factor (usually half)."
        concepts: [logarithms, divide_and_conquer]

  # =========================================================
  # SLOT 3 — BASIC LOOP ANALYSIS
  # =========================================================
  - slot_id: CORE_SLOT_3_COMPLEXITY_LOOPS
    mental_install: "Linear loops dominate constant operations."
    invariant: "Loops define the multiplier of operations."
    mastery_signals:
      - Identifies dominant terms in expressions
    hard_failures:
      - Counts inner operations incorrectly

    templates:
      - id: complexity_s1_analyze_loops
        type: explanation
        difficulty: medium
        prompt: |
          Analyze the following code:
          ```python
          for i in range(n):
              for j in range(100):
                  print(i, j)
          ```
          What is the Big O time complexity and why?
        rubric: >
          Must identify O(n). Explain that 100 is a constant and the outer loop is the dominant factor.
        concepts: [dominance, constant_factors]

  # =========================================================
  # SLOT 4 — NESTED DEPENDENT LOOPS
  # =========================================================
  - slot_id: CORE_SLOT_4_COMPLEXITY_NESTED
    mental_install: "Nested dependence creates polynomial growth."
    invariant: "Summation of 1..N scales as N^2."
    mastery_signals:
      - Cannot identify nested loop complexity
    hard_failures:
      - Thinks N + N is N^2

    templates:
      - id: complexity_s1_nested_dependent
        type: explanation
        difficulty: hard
        prompt: |
          Analyze this code:
          ```python
          for i in range(n):
              for j in range(i):
                  print(i, j)
          ```
          The inner loop runs 1+2+3...+N times. What is the Big O and why?
        rubric: "Must identify O(N^2). Explains that (N*(N-1))/2 still simplifies to N^2."
        concepts: [summation, quadratic_growth]

  # =========================================================
  # SLOT 5 — SPACE COMPLEXITY
  # =========================================================
  - slot_id: CORE_SLOT_5_COMPLEXITY_SPACE
    mental_install: "Memory usage scales independently of time."
    invariant: "Allocation size relative to N determines space complexity."
    mastery_signals:
      - Separates auxiliary space from input space
    hard_failures:
      - Thinks time = space

    templates:
      - id: complexity_s1_space_vs_time
        type: mcq
        difficulty: medium
        prompt: "An algorithm creates a new array of size N inside a loop that runs N times. What is the SPACE complexity?"
        options:
          - "O(1)"
          - "O(N)"
          - "O(N^2)"
          - "O(log N)"
        correct_answer: 1
        concepts: [space_complexity, memory_allocation]

  # =========================================================
  # SLOT 6 — WORST CASE LOGIC
  # =========================================================
  - slot_id: CORE_SLOT_6_COMPLEXITY_WORST_CASE
    mental_install: "Engineering relies on guarantees, not luck."
    invariant: "Worst case dictates system limits."
    mastery_signals:
      - Explains worst-case vs average-case
    hard_failures:
      - Optimizes for best case only

    templates:
      - id: complexity_s1_worst_case_logic
        type: explanation
        difficulty: easy
        prompt: "Why do engineers usually focus on Worst-Case (Big O) rather than Best-Case (Big Omega)?"
        rubric: "Must mention reliability, performance guarantees, and scalability safety."
        concepts: [worst_case, engineering_tradeoffs]
